.globl accumulatorone
.globl accumulatortwo
.globl accumulatorthree
.globl accumulatorfour
.globl accumulatorfive

#Accumulator:
#Inputs: a0 contains a pointer to an array of nonzero integers, terminated with 0
#Output: a0 should return the sum of the elements of the array
#
#Example: Let a0 = [1,2,3,4,5,6,7,0]
#
#         Then the expected output (in a0) is 1+2+3+4+5+6+7=28

#DO NOT EDIT THIS FILE
#We have provided five versions of accumulator. Only one is correct, though all five pass the sanity test above.

accumulatorone:
    lw t0, 0(a0)       # Load the value from memory into t0 (assuming s0 is being used as t0 in the original code)
    beq t0, x0, Endone # Check if the loaded value is zero
    addi sp, sp, -8    # Allocate space on the stack
    sw t0, 0(sp)       # Save t0 onto the stack
    sw ra, 4(sp)       # Save return address onto the stack
    addi a0, a0, 4     # Increment the argument pointer
    jal accumulatorone # Recursive call
    lw t1, 0(sp)       # Restore t0 from the stack
    lw ra, 4(sp)       # Restore return address from the stack
    addi sp, sp, 8     # Deallocate stack space
    add a0, a0, t1     # Accumulate the result
    jr ra              # Return to the calling function

Endone:
    li a0, 0           # Load return value 0
    jr ra              # Return

accumulatortwo:
	addi sp sp 4
	sw s0 0(sp)
	li t0 0
	li s0 0
Looptwo:
	slli t1 t0 2
	add t2 a0 t1
	lw t3 0(t2)
	add s0 s0 t3
	addi t0 t0 1
	bnez t3 Looptwo
	j Endtwo
Endtwo:
	mv a0 s0
	lw s0 0(sp)
	addi sp sp -4
	jr ra

accumulatorthree:
	addi sp sp -8
	sw s0 0(sp)
	sw ra 4(sp)
	lw s0 0(a0)
	beq s0 x0 TailCasethree
	addi a0 a0 4
	jal accumulatorthree
	add a0 a0 s0
	j Epiloguethree
TailCasethree:
	mv a0 x0
	j Epiloguethree
Epiloguethree:	
	lw s0 0(sp)
	lw ra 4(sp)
	addi sp sp 8
	jr ra

accumulatorfour:
    li t2, 0          # Initialize t2 to 0
    addi sp sp -8
    sw ra 4(sp)
Loopfour:
    lw t1, 0(a0)      # Load value from memory into t1
    beq t1, x0, Endfour # Check if t1 is zero, if so, exit loop
    add t2, t2, t1    # Accumulate t1 into t2
    addi a0, a0, 4    # Increment memory address
    j Loopfour # Jump back to the beginning of the loop
Endfour:
    mv a0, t2         # Move the accumulated value to a0
    lw ra 4(sp)
    addi sp sp 8
    jr ra             # Jump back to the return address
 
accumulatorfive:
	addi sp sp -8
	sw s0 0(sp)
	sw ra 4(sp)
	mv s0 a0
	lw a0 0(a0)
Loopfive:
	addi s0 s0 4
	lw t0 0(s0)
	add a0 a0 t0
	bne t0 x0 Loopfive
	lw s0 0(sp)
	lw ra 4(sp)
	addi sp sp 8
	jr ra
